% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utilities.R
\name{fuseOverlaps}
\alias{fuseOverlaps}
\title{Fuse two sets of GRanges into larger granges}
\usage{
fuseOverlaps(query, subject, keep.singletons = TRUE, ...)
}
\arguments{
\item{query, subject, ...}{as for \code{findOverlaps}}

\item{keep.singletons}{if FALSE, do not return GRange elements that did not overlap with anything}
}
\value{
a GRanges object. \code{n.orig.members} contains the number of 
original GRanges elements fused into the current one. The
\code{n.queryhits} shows how many came from \code{query},
\code{n.subjecthits} shows how many came from \code{subject}. If
\code{keep.singletons} was TRUE, their sum is always
\code{n.orig.members}
}
\description{
When comparing sets of features such as binding peaks, it is
sometimes necessary to fuse their GRanges into larger GRanges.
This is made difficult by the fact that often such ranges are clustered.
This function constructs 'islands' of connected components and fuses them
one GRange element for all elements of the cluster. See example.
}
\note{
In this simple case, \code{fuseOverlaps(gr1,gr2)} is identical
to \code{reduce(c(gr1,gr2))} which is much faster. However, it does
not yield the number of original query and subject GRanges that ended
up in the fused GRanges element.
}
\examples{
gr1 <- GRanges(ranges=IRanges(start=c(1,21,31),width=c(5,5,12)), strand='*',seqnames='X', mcols=DataFrame(ID=letters[1:3]))
gr2 <- GRanges(ranges=IRanges(start=c(11, 19, 41),width=c(5,14,12)),strand='*',seqnames='X', mcols=DataFrame(ID=LETTERS[1:3]))
fuseOverlaps(gr1,gr2)
}
